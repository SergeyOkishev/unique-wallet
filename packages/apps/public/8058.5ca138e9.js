((typeof self !== 'undefined' ? self : this)["webpackChunk_polkadot_apps"] = (typeof self !== 'undefined' ? self : this)["webpackChunk_polkadot_apps"] || []).push([[8058],{

/***/ 77289:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "g": () => (/* binding */ DEV_PHRASE)
/* harmony export */ });
/* unused harmony export DEV_SEED */
// Copyright 2017-2021 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
// default substrate dev phrase
const DEV_PHRASE = 'bottom drive obey lake curtain smoke basket hold race lonely fit walk'; // seed from the above phrase

const DEV_SEED = '0xfac7959dbfe72f052e5a0c3c8d6530f202b02fd8f9f5ca3580ec8deb7797479e';

/***/ }),

/***/ 88058:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Keyring": () => (/* reexport */ Keyring),
  "decodeAddress": () => (/* reexport */ util_crypto_index_js_.decodeAddress),
  "default": () => (/* binding */ keyring),
  "encodeAddress": () => (/* reexport */ util_crypto_index_js_.encodeAddress),
  "packageInfo": () => (/* reexport */ packageInfo_packageInfo),
  "setSS58Format": () => (/* reexport */ util_crypto_index_js_.setSS58Format)
});

// EXTERNAL MODULE: consume shared module (default) @polkadot/util@^6.7.1 (strict) (fallback: ../../node_modules/@polkadot/util/index.js)
var index_js_ = __webpack_require__(13948);
// EXTERNAL MODULE: ../../node_modules/@polkadot/util-crypto/packageInfo.js
var packageInfo = __webpack_require__(58534);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/keyring/packageInfo.js
// Copyright 2017-2021 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Auto-generated by @polkadot/dev, do not edit
const packageInfo_packageInfo = {
  name: '@polkadot/keyring',
  version: '6.7.1'
};
;// CONCATENATED MODULE: ../../node_modules/@polkadot/keyring/detectPackage.js
// Copyright 2017-2021 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0



(0,index_js_.detectPackage)(packageInfo_packageInfo, typeof __dirname !== 'undefined' && __dirname, [index_js_.packageInfo, packageInfo/* packageInfo */.b]);
// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js
var classPrivateFieldLooseBase = __webpack_require__(89539);
// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js
var classPrivateFieldLooseKey = __webpack_require__(38879);
// EXTERNAL MODULE: consume shared module (default) @polkadot/util-crypto@^6.7.1 (strict) (fallback: ../../node_modules/@polkadot/util-crypto/index.js)
var util_crypto_index_js_ = __webpack_require__(21050);
// EXTERNAL MODULE: ../../node_modules/@polkadot/keyring/defaults.js
var defaults = __webpack_require__(77289);
// EXTERNAL MODULE: ../../node_modules/@polkadot/keyring/pair/index.js + 4 modules
var keyring_pair = __webpack_require__(99026);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/keyring/pairs.js


// Copyright 2017-2021 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0



var _map = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("map");

class Pairs {
  constructor() {
    Object.defineProperty(this, _map, {
      writable: true,
      value: {}
    });
  }

  add(pair) {
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _map)[_map][(0,util_crypto_index_js_.decodeAddress)(pair.address).toString()] = pair;
    return pair;
  }

  all() {
    return Object.values((0,classPrivateFieldLooseBase/* default */.Z)(this, _map)[_map]);
  }

  get(address) {
    const pair = (0,classPrivateFieldLooseBase/* default */.Z)(this, _map)[_map][(0,util_crypto_index_js_.decodeAddress)(address).toString()];

    (0,index_js_.assert)(pair, () => `Unable to retrieve keypair '${(0,index_js_.isU8a)(address) || (0,index_js_.isHex)(address) ? (0,index_js_.u8aToHex)((0,index_js_.u8aToU8a)(address)) : address}'`);
    return pair;
  }

  remove(address) {
    delete (0,classPrivateFieldLooseBase/* default */.Z)(this, _map)[_map][(0,util_crypto_index_js_.decodeAddress)(address).toString()];
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/keyring/keyring.js


// Copyright 2017-2021 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0





const keypairFromSeed = {
  ecdsa: seed => (0,util_crypto_index_js_.secp256k1KeypairFromSeed)(seed),
  ed25519: seed => (0,util_crypto_index_js_.naclKeypairFromSeed)(seed),
  ethereum: seed => (0,util_crypto_index_js_.secp256k1KeypairFromSeed)(seed),
  sr25519: seed => (0,util_crypto_index_js_.schnorrkelKeypairFromSeed)(seed)
};
/**
 * # @polkadot/keyring
 *
 * ## Overview
 *
 * @name Keyring
 * @summary Keyring management of user accounts
 * @description Allows generation of keyring pairs from a variety of input combinations, such as
 * json object containing account address or public key, account metadata, and account encoded using
 * `addFromJson`, or by providing those values as arguments separately to `addFromAddress`,
 * or by providing the mnemonic (seed phrase) and account metadata as arguments to `addFromMnemonic`.
 * Stores the keyring pairs in a keyring pair dictionary. Removal of the keyring pairs from the keyring pair
 * dictionary is achieved using `removePair`. Retrieval of all the stored pairs via `getPairs` or perform
 * lookup of a pair for a given account address or public key using `getPair`. JSON metadata associated with
 * an account may be obtained using `toJson` accompanied by the account passphrase.
 */

var _pairs = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("pairs");

var _type = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("type");

var _ss = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("ss58");

class Keyring {
  constructor(options = {}) {
    Object.defineProperty(this, _pairs, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _type, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _ss, {
      writable: true,
      value: void 0
    });
    this.decodeAddress = util_crypto_index_js_.decodeAddress;

    this.encodeAddress = (address, ss58Format) => {
      return this.type === 'ethereum' ? (0,util_crypto_index_js_.ethereumEncode)(address) : (0,util_crypto_index_js_.encodeAddress)(address, (0,index_js_.isUndefined)(ss58Format) ? (0,classPrivateFieldLooseBase/* default */.Z)(this, _ss)[_ss] : ss58Format);
    };

    options.type = options.type || 'ed25519';
    (0,index_js_.assert)(['ecdsa', 'ethereum', 'ed25519', 'sr25519'].includes(options.type || 'undefined'), () => `Expected a keyring type of either 'ed25519', 'sr25519', 'ethereum' or 'ecdsa', found '${options.type || 'unknown'}`);
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _pairs)[_pairs] = new Pairs();
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _ss)[_ss] = options.ss58Format;
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _type)[_type] = options.type;
  }
  /**
   * @description retrieve the pairs (alias for getPairs)
   */


  get pairs() {
    return this.getPairs();
  }
  /**
   * @description retrieve the publicKeys (alias for getPublicKeys)
   */


  get publicKeys() {
    return this.getPublicKeys();
  }
  /**
   * @description Returns the type of the keyring, ed25519, sr25519 or ecdsa
   */


  get type() {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _type)[_type];
  }
  /**
   * @name addPair
   * @summary Stores an account, given a keyring pair, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   */


  addPair(pair) {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _pairs)[_pairs].add(pair);
  }
  /**
   * @name addFromAddress
   * @summary Stores an account, given an account address, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   * @description Allows user to explicitly provide separate inputs including account address or public key, and optionally
   * the associated account metadata, and the default encoded value as arguments (that may be obtained from the json file
   * of an account backup), and then generates a keyring pair from them that it passes to
   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
   */


  addFromAddress(address, meta = {}, encoded = null, type = this.type, ignoreChecksum, encType) {
    const publicKey = this.decodeAddress(address, ignoreChecksum);
    return this.addPair((0,keyring_pair/* createPair */.s)({
      toSS58: this.encodeAddress,
      type
    }, {
      publicKey,
      secretKey: new Uint8Array()
    }, meta, encoded, encType));
  }
  /**
   * @name addFromJson
   * @summary Stores an account, given JSON data, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   * @description Allows user to provide a json object argument that contains account information (that may be obtained from the json file
   * of an account backup), and then generates a keyring pair from it that it passes to
   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
   */


  addFromJson(json, ignoreChecksum) {
    return this.addPair(this.createFromJson(json, ignoreChecksum));
  }
  /**
   * @name addFromMnemonic
   * @summary Stores an account, given a mnemonic, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   * @description Allows user to provide a mnemonic (seed phrase that is provided when account is originally created)
   * argument and a metadata argument that contains account information (that may be obtained from the json file
   * of an account backup), and then generates a keyring pair from it that it passes to
   * `addPair` to stores in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
   */


  addFromMnemonic(mnemonic, meta = {}, type = this.type) {
    return this.addFromUri(mnemonic, meta, type);
  }
  /**
   * @name addFromPair
   * @summary Stores an account created from an explicit publicKey/secreteKey combination
   */


  addFromPair(pair, meta = {}, type = this.type) {
    return this.addPair(this.createFromPair(pair, meta, type));
  }
  /**
   * @name addFromSeed
   * @summary Stores an account, given seed data, as a Key/Value (public key, pair) in Keyring Pair Dictionary
   * @description Stores in a keyring pair dictionary the public key of the pair as a key and the pair as the associated value.
   * Allows user to provide the account seed as an argument, and then generates a keyring pair from it that it passes to
   * `addPair` to store in a keyring pair dictionary the public key of the generated pair as a key and the pair as the associated value.
   */


  addFromSeed(seed, meta = {}, type = this.type) {
    return this.addPair((0,keyring_pair/* createPair */.s)({
      toSS58: this.encodeAddress,
      type
    }, keypairFromSeed[type](seed), meta, null));
  }
  /**
   * @name addFromUri
   * @summary Creates an account via an suri
   * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed). The secret can be a hex string, mnemonic phrase or a string (to be padded)
   */


  addFromUri(suri, meta = {}, type = this.type) {
    return this.addPair(this.createFromUri(suri, meta, type));
  }
  /**
   * @name createFromJson
   * @description Creates a pair from a JSON keyfile
   */


  createFromJson({
    address,
    encoded,
    encoding: {
      content,
      type,
      version
    },
    meta
  }, ignoreChecksum) {
    (0,index_js_.assert)(version !== '3' || content[0] === 'pkcs8', () => `Unable to decode non-pkcs8 type, [${content.join(',')}] found}`);
    const cryptoType = version === '0' || !Array.isArray(content) ? this.type : content[1];
    const encType = !Array.isArray(type) ? [type] : type;
    (0,index_js_.assert)(['ed25519', 'sr25519', 'ecdsa', 'ethereum'].includes(cryptoType), () => `Unknown crypto type ${cryptoType}`); // Here the address and publicKey are 32 bytes and isomorphic. This is why the address field needs to be the public key for ethereum type pairs

    const publicKey = (0,index_js_.isHex)(address) ? (0,index_js_.hexToU8a)(address) : this.decodeAddress(address, ignoreChecksum);
    const decoded = (0,index_js_.isHex)(encoded) ? (0,index_js_.hexToU8a)(encoded) : (0,util_crypto_index_js_.base64Decode)(encoded);
    return (0,keyring_pair/* createPair */.s)({
      toSS58: this.encodeAddress,
      type: cryptoType
    }, {
      publicKey,
      secretKey: new Uint8Array()
    }, meta, decoded, encType);
  }
  /**
   * @name createFromPair
   * @summary Creates a pair from an explicit publicKey/secreteKey combination
   */


  createFromPair(pair, meta = {}, type = this.type) {
    return (0,keyring_pair/* createPair */.s)({
      toSS58: this.encodeAddress,
      type
    }, pair, meta, null);
  }
  /**
   * @name createFromUri
   * @summary Creates a Keypair from an suri
   * @description This creates a pair from the suri, but does not add it to the keyring
   */


  createFromUri(_suri, meta = {}, type = this.type) {
    // here we only aut-add the dev phrase if we have a hard-derived path
    const suri = _suri.startsWith('//') ? `${defaults/* DEV_PHRASE */.g}${_suri}` : _suri;
    const {
      derivePath,
      password,
      path,
      phrase
    } = (0,util_crypto_index_js_.keyExtractSuri)(suri);
    let seed;
    const isPhraseHex = (0,index_js_.isHex)(phrase, 256);

    if (isPhraseHex) {
      seed = (0,index_js_.hexToU8a)(phrase);
    } else {
      const str = phrase;
      const parts = str.split(' ');

      if ([12, 15, 18, 21, 24].includes(parts.length)) {
        seed = type === 'ethereum' ? (0,util_crypto_index_js_.mnemonicToLegacySeed)(phrase, '', false, 64) : (0,util_crypto_index_js_.mnemonicToMiniSecret)(phrase, password);
      } else {
        (0,index_js_.assert)(str.length <= 32, 'specified phrase is not a valid mnemonic and is invalid as a raw seed at > 32 bytes');
        seed = (0,index_js_.stringToU8a)(str.padEnd(32));
      }
    }

    const derived = type === 'ethereum' ? isPhraseHex ? keypairFromSeed[type](seed) // for eth, if the private key is provided as suri, it must be derived only once
    : (0,util_crypto_index_js_.hdEthereum)(seed, derivePath.substring(1)) : (0,util_crypto_index_js_.keyFromPath)(keypairFromSeed[type](seed), path, type);
    return (0,keyring_pair/* createPair */.s)({
      toSS58: this.encodeAddress,
      type
    }, derived, meta, null);
  }
  /**
   * @name encodeAddress
   * @description Encodes the input into an ss58 representation
   */


  /**
   * @name getPair
   * @summary Retrieves an account keyring pair from the Keyring Pair Dictionary, given an account address
   * @description Returns a keyring pair value from the keyring pair dictionary by performing
   * a key lookup using the provided account address or public key (after decoding it).
   */
  getPair(address) {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _pairs)[_pairs].get(address);
  }
  /**
   * @name getPairs
   * @summary Retrieves all account keyring pairs from the Keyring Pair Dictionary
   * @description Returns an array list of all the keyring pair values that are stored in the keyring pair dictionary.
   */


  getPairs() {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _pairs)[_pairs].all();
  }
  /**
   * @name getPublicKeys
   * @summary Retrieves Public Keys of all Keyring Pairs stored in the Keyring Pair Dictionary
   * @description Returns an array list of all the public keys associated with each of the keyring pair values that are stored in the keyring pair dictionary.
   */


  getPublicKeys() {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _pairs)[_pairs].all().map(({
      publicKey
    }) => publicKey);
  }
  /**
   * @name removePair
   * @description Deletes the provided input address or public key from the stored Keyring Pair Dictionary.
   */


  removePair(address) {
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _pairs)[_pairs].remove(address);
  }
  /**
   * @name setSS58Format;
   * @description Sets the ss58 format for the keyring
   */


  setSS58Format(ss58) {
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _ss)[_ss] = ss58;
  }
  /**
   * @name toJson
   * @summary Returns a JSON object associated with the input argument that contains metadata assocated with an account
   * @description Returns a JSON object containing the metadata associated with an account
   * when valid address or public key and when the account passphrase is provided if the account secret
   * is not already unlocked and available in memory. Note that in [Polkadot-JS Apps](https://github.com/polkadot-js/apps) the user
   * may backup their account to a JSON file that contains this information.
   */


  toJson(address, passphrase) {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _pairs)[_pairs].get(address).toJson(passphrase);
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/keyring/index.js
// Copyright 2017-2021 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0




/* harmony default export */ const keyring = (Keyring);


/***/ }),

/***/ 99026:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "s": () => (/* binding */ createPair)
});

// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(51119);
// EXTERNAL MODULE: consume shared module (default) @polkadot/util@^6.7.1 (strict) (fallback: ../../node_modules/@polkadot/util/index.js)
var index_js_ = __webpack_require__(13948);
// EXTERNAL MODULE: consume shared module (default) @polkadot/util-crypto@^6.7.1 (strict) (fallback: ../../node_modules/@polkadot/util-crypto/index.js)
var util_crypto_index_js_ = __webpack_require__(21050);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/keyring/pair/defaults.js
// Copyright 2017-2021 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0
const PKCS8_DIVIDER = new Uint8Array([161, 35, 3, 33, 0]);
const PKCS8_HEADER = new Uint8Array([48, 83, 2, 1, 1, 48, 5, 6, 3, 43, 101, 112, 4, 34, 4, 32]);
const PUB_LENGTH = 32;
const SALT_LENGTH = 32;
const SEC_LENGTH = 64;
const SEED_LENGTH = 32;
;// CONCATENATED MODULE: ../../node_modules/@polkadot/keyring/pair/decode.js
// Copyright 2017-2021 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0



const SEED_OFFSET = PKCS8_HEADER.length;
function decodePair(passphrase, encrypted, _encType) {
  const encType = Array.isArray(_encType) || (0,index_js_.isUndefined)(_encType) ? _encType : [_encType];
  const decrypted = (0,util_crypto_index_js_.jsonDecryptData)(encrypted, passphrase, encType);
  const header = decrypted.subarray(0, PKCS8_HEADER.length);
  (0,index_js_.assert)((0,index_js_.u8aEq)(header, PKCS8_HEADER), 'Invalid Pkcs8 header found in body');
  let secretKey = decrypted.subarray(SEED_OFFSET, SEED_OFFSET + SEC_LENGTH);
  let divOffset = SEED_OFFSET + SEC_LENGTH;
  let divider = decrypted.subarray(divOffset, divOffset + PKCS8_DIVIDER.length); // old-style, we have the seed here

  if (!(0,index_js_.u8aEq)(divider, PKCS8_DIVIDER)) {
    divOffset = SEED_OFFSET + SEED_LENGTH;
    secretKey = decrypted.subarray(SEED_OFFSET, divOffset);
    divider = decrypted.subarray(divOffset, divOffset + PKCS8_DIVIDER.length);
    (0,index_js_.assert)((0,index_js_.u8aEq)(divider, PKCS8_DIVIDER), 'Invalid Pkcs8 divider found in body');
  }

  const pubOffset = divOffset + PKCS8_DIVIDER.length;
  const publicKey = decrypted.subarray(pubOffset, pubOffset + PUB_LENGTH);
  return {
    publicKey,
    secretKey
  };
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/keyring/pair/encode.js
// Copyright 2017-2021 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0



function encodePair({
  publicKey,
  secretKey
}, passphrase) {
  (0,index_js_.assert)(secretKey, 'Expected a valid secretKey to be passed to encode');
  const encoded = (0,index_js_.u8aConcat)(PKCS8_HEADER, secretKey, PKCS8_DIVIDER, publicKey);

  if (!passphrase) {
    return encoded;
  }

  const {
    params,
    password,
    salt
  } = (0,util_crypto_index_js_.scryptEncode)(passphrase);
  const {
    encrypted,
    nonce
  } = (0,util_crypto_index_js_.naclEncrypt)(encoded, password.subarray(0, 32));
  return (0,index_js_.u8aConcat)((0,util_crypto_index_js_.scryptToU8a)(salt, params), nonce, encrypted);
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/keyring/pair/toJson.js


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0

function pairToJson(type, {
  address,
  meta
}, encoded, isEncrypted) {
  return _objectSpread(_objectSpread({}, (0,util_crypto_index_js_.jsonEncryptFormat)(encoded, ['pkcs8', type], isEncrypted)), {}, {
    address,
    meta
  });
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/keyring/pair/index.js


function pair_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function pair_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { pair_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { pair_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/keyring authors & contributors
// SPDX-License-Identifier: Apache-2.0





const SIG_TYPE_NONE = new Uint8Array();
const TYPE_FROM_SEED = {
  ecdsa: util_crypto_index_js_.secp256k1KeypairFromSeed,
  ed25519: util_crypto_index_js_.naclKeypairFromSeed,
  ethereum: util_crypto_index_js_.secp256k1KeypairFromSeed,
  sr25519: util_crypto_index_js_.schnorrkelKeypairFromSeed
};
const TYPE_PREFIX = {
  ecdsa: new Uint8Array([2]),
  ed25519: new Uint8Array([0]),
  ethereum: new Uint8Array([2]),
  sr25519: new Uint8Array([1])
};
const TYPE_SIGNATURE = {
  ecdsa: (m, p) => (0,util_crypto_index_js_.secp256k1Sign)(m, p, 'blake2'),
  ed25519: util_crypto_index_js_.naclSign,
  ethereum: (m, p) => (0,util_crypto_index_js_.secp256k1Sign)(m, p, 'keccak'),
  sr25519: util_crypto_index_js_.schnorrkelSign
};
const TYPE_ADDRESS = {
  ecdsa: p => p.length > 32 ? (0,util_crypto_index_js_.blake2AsU8a)(p) : p,
  ed25519: p => p,
  ethereum: p => p.length === 20 ? p : (0,util_crypto_index_js_.keccakAsU8a)((0,util_crypto_index_js_.secp256k1Expand)(p)),
  sr25519: p => p
}; // Not 100% correct, since it can be a Uint8Array, but an invalid one - just say "undefined" is anything non-valid

function isLocked(secretKey) {
  return !secretKey || secretKey.length === 0 || secretKey.every(b => b === 0);
}

function vrfHash(proof, context, extra) {
  return (0,util_crypto_index_js_.blake2AsU8a)((0,index_js_.u8aConcat)(context || '', extra || '', proof));
}
/**
 * @name createPair
 * @summary Creates a keyring pair object
 * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.
 * The keyring pair stores the account state including the encoded address and associated metadata.
 *
 * It has properties whose values are functions that may be called to perform account actions:
 *
 * - `address` function retrieves the address associated with the account.
 * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.
 * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key
 * and associated secret key that are then available in memory, and changes the account address stored in the
 * state of the pair to correspond to the address of the decoded public key.
 * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair
 * and when the secret key is in memory (when the account pair is not locked) it returns an encoded
 * public key of the account.
 * - `meta` is the metadata that is stored in the state of the pair, either when it was originally
 * created or set via `setMeta`.
 * - `publicKey` returns the public key stored in memory for the pair.
 * - `sign` may be used to return a signature by signing a provided message with the secret
 * key (if it is in memory) using Nacl.
 * - `toJson` calls another `toJson` function and provides the state of the pair,
 * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account
 * that it generates using the secret key from memory (if it has been made available in memory)
 * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`
 * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).
 * The `toJson` function that it calls returns a JSON object with properties including the `address`
 * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,
 * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`
 * property that indicates whether the public key value of the `encoded` property is encoded or not.
 */


function createPair({
  toSS58,
  type
}, {
  publicKey,
  secretKey
}, meta = {}, encoded = null, encTypes) {
  const decodePkcs8 = (passphrase, userEncoded) => {
    const decoded = decodePair(passphrase, userEncoded || encoded, encTypes);

    if (decoded.secretKey.length === 64) {
      publicKey = decoded.publicKey;
      secretKey = decoded.secretKey;
    } else {
      const pair = TYPE_FROM_SEED[type](decoded.secretKey);
      publicKey = pair.publicKey;
      secretKey = pair.secretKey;
    }
  };

  const recode = passphrase => {
    isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);
    encoded = encodePair({
      publicKey,
      secretKey
    }, passphrase); // re-encode, latest version

    encTypes = undefined; // swap to defaults, latest version follows

    return encoded;
  };

  const encodeAddress = () => {
    const raw = TYPE_ADDRESS[type](publicKey);
    return type === 'ethereum' ? (0,util_crypto_index_js_.ethereumEncode)(raw) : toSS58(raw);
  };

  return {
    get address() {
      return encodeAddress();
    },

    get addressRaw() {
      const raw = TYPE_ADDRESS[type](publicKey);
      return type === 'ethereum' ? raw.slice(-20) : raw;
    },

    get isLocked() {
      return isLocked(secretKey);
    },

    get meta() {
      return meta;
    },

    get publicKey() {
      return publicKey;
    },

    get type() {
      return type;
    },

    // eslint-disable-next-line sort-keys
    decodePkcs8,
    derive: (suri, meta) => {
      (0,index_js_.assert)(type !== 'ethereum', 'Unable to derive on this keypair');
      (0,index_js_.assert)(!isLocked(secretKey), 'Cannot derive on a locked keypair');
      const {
        path
      } = (0,util_crypto_index_js_.keyExtractPath)(suri);
      const derived = (0,util_crypto_index_js_.keyFromPath)({
        publicKey,
        secretKey
      }, path, type);
      return createPair({
        toSS58,
        type
      }, derived, meta, null);
    },
    encodePkcs8: passphrase => {
      return recode(passphrase);
    },
    lock: () => {
      secretKey = new Uint8Array();
    },
    setMeta: additional => {
      meta = pair_objectSpread(pair_objectSpread({}, meta), additional);
    },
    sign: (message, options = {}) => {
      (0,index_js_.assert)(!isLocked(secretKey), 'Cannot sign with a locked key pair');
      return (0,index_js_.u8aConcat)(options.withType ? TYPE_PREFIX[type] : SIG_TYPE_NONE, TYPE_SIGNATURE[type]((0,index_js_.u8aToU8a)(message), {
        publicKey,
        secretKey
      }));
    },
    toJson: passphrase => {
      // NOTE: For ecdsa and ethereum, the publicKey cannot be extracted from the address. For these
      // pass the hex-encoded publicKey through to the address portion of the JSON (before decoding)
      const address = ['ecdsa', 'ethereum'].includes(type) ? (0,index_js_.u8aToHex)((0,util_crypto_index_js_.secp256k1Compress)(publicKey)) : encodeAddress();
      return pairToJson(type, {
        address,
        meta
      }, recode(passphrase), !!passphrase);
    },
    unlock: passphrase => {
      return decodePkcs8(passphrase);
    },
    verify: (message, signature, _signerPublic) => {
      return (0,util_crypto_index_js_.signatureVerify)(message, signature, TYPE_ADDRESS[type]((0,index_js_.u8aToU8a)(_signerPublic))).isValid;
    },
    vrfSign: (message, context, extra) => {
      (0,index_js_.assert)(!isLocked(secretKey), 'Cannot sign with a locked key pair');

      if (type === 'sr25519') {
        return (0,util_crypto_index_js_.schnorrkelVrfSign)(message, {
          secretKey
        }, context, extra);
      }

      const proof = TYPE_SIGNATURE[type]((0,index_js_.u8aToU8a)(message), {
        publicKey,
        secretKey
      });
      return (0,index_js_.u8aConcat)(vrfHash(proof, context, extra), proof);
    },
    vrfVerify: (message, vrfResult, _signerPublic, context, extra) => {
      const signerPublic = TYPE_ADDRESS[type]((0,index_js_.u8aToU8a)(_signerPublic));

      if (type === 'sr25519') {
        return (0,util_crypto_index_js_.schnorrkelVrfVerify)(message, vrfResult, publicKey, context, extra);
      }

      const result = (0,util_crypto_index_js_.signatureVerify)(message, (0,index_js_.u8aConcat)(TYPE_PREFIX[type], vrfResult.subarray(32)), signerPublic);
      return result.isValid && (0,index_js_.u8aEq)(vrfResult.subarray(0, 32), vrfHash(vrfResult.subarray(32), context, extra));
    }
  };
}

/***/ }),

/***/ 58534:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": () => (/* binding */ packageInfo)
/* harmony export */ });
// Copyright 2017-2021 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Auto-generated by @polkadot/dev, do not edit
const packageInfo = {
  name: '@polkadot/util-crypto',
  version: '6.7.1'
};

/***/ })

}]);