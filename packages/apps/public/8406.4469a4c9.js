((typeof self !== 'undefined' ? self : this)["webpackChunk_polkadot_apps"] = (typeof self !== 'undefined' ? self : this)["webpackChunk_polkadot_apps"] || []).push([[8406],{

/***/ 8406:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Abi": () => (/* reexport */ Abi),
  "BlueprintPromise": () => (/* reexport */ Blueprint),
  "BlueprintRx": () => (/* reexport */ rx_Blueprint_Blueprint),
  "CodePromise": () => (/* reexport */ Code),
  "CodeRx": () => (/* reexport */ rx_Code_Code),
  "ContractPromise": () => (/* reexport */ Contract),
  "ContractRx": () => (/* reexport */ rx_Contract_Contract),
  "packageInfo": () => (/* reexport */ packageInfo_packageInfo)
});

// EXTERNAL MODULE: ../../node_modules/@polkadot/api/packageInfo.js
var packageInfo = __webpack_require__(20762);
// EXTERNAL MODULE: ../../node_modules/@polkadot/types/packageInfo.js
var types_packageInfo = __webpack_require__(31760);
// EXTERNAL MODULE: consume shared module (default) @polkadot/util@^6.7.1 (strict) (fallback: ../../node_modules/@polkadot/util/index.js)
var index_js_ = __webpack_require__(13948);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/packageInfo.js
// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Auto-generated by @polkadot/dev, do not edit
const packageInfo_packageInfo = {
  name: '@polkadot/api-contract',
  version: '4.13.1'
};
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/detectPackage.js
// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0




(0,index_js_.detectPackage)(packageInfo_packageInfo, typeof __dirname !== 'undefined' && __dirname, [packageInfo/* packageInfo */.b, types_packageInfo/* packageInfo */.b]);
// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(51119);
// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js
var classPrivateFieldLooseBase = __webpack_require__(89539);
// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js
var classPrivateFieldLooseKey = __webpack_require__(38879);
// EXTERNAL MODULE: ../../node_modules/@polkadot/types/create/registry.js + 5 modules
var registry = __webpack_require__(67795);
// EXTERNAL MODULE: ../../node_modules/@polkadot/types/create/encodeTypes.js
var encodeTypes = __webpack_require__(23195);
// EXTERNAL MODULE: ../../node_modules/@polkadot/types/create/types.js
var types = __webpack_require__(77847);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/MetaRegistry.js




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0



// convert the offset into project-specific, index-1
function getRegistryOffset(id, typeOffset) {
  return id.toNumber() - typeOffset;
}
const PRIMITIVE_ALIAS = {
  Char: 'u32',
  // Rust char is 4-bytes
  Str: 'Text'
};
const PRIMITIVE_ALWAYS = ['AccountId', 'AccountIndex', 'Address', 'Balance'];

var _siTypes = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("siTypes");

var _getMetaType = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("getMetaType");

var _extract = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("extract");

var _extractArray = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("extractArray");

var _extractFields = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("extractFields");

var _extractPrimitive = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("extractPrimitive");

var _extractPrimitivePath = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("extractPrimitivePath");

var _extractSequence = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("extractSequence");

var _extractTuple = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("extractTuple");

var _extractVariant = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("extractVariant");

var _extractVariantSub = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("extractVariantSub");

class MetaRegistry extends registry/* TypeRegistry */.P {
  constructor(metadataVersion, chainProperties) {
    super(); // type indexes are 1-based pre-1.0 and 0-based post-1.0

    this.metaTypeDefs = [];
    this.typeOffset = void 0;
    Object.defineProperty(this, _siTypes, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _getMetaType, {
      writable: true,
      value: id => {
        const type = (0,classPrivateFieldLooseBase/* default */.Z)(this, _siTypes)[_siTypes][getRegistryOffset(id, this.typeOffset)];

        (0,index_js_.assert)(!(0,index_js_.isUndefined)(type), () => `getMetaType:: Unable to find ${id.toNumber()} in type values`);
        return this.createType('SiType', type);
      }
    });
    Object.defineProperty(this, _extract, {
      writable: true,
      value: (type, id) => {
        var _path$pop;

        const path = [...type.path];
        const isPrimitivePath = !!path.length && (path.length > 2 && path[0].eq('ink_env') && path[1].eq('types') || PRIMITIVE_ALWAYS.includes(path[path.length - 1].toString()));
        let typeDef;

        if (isPrimitivePath) {
          typeDef = (0,classPrivateFieldLooseBase/* default */.Z)(this, _extractPrimitivePath)[_extractPrimitivePath](type);
        } else if (type.def.isPrimitive) {
          typeDef = (0,classPrivateFieldLooseBase/* default */.Z)(this, _extractPrimitive)[_extractPrimitive](type);
        } else if (type.def.isComposite) {
          typeDef = (0,classPrivateFieldLooseBase/* default */.Z)(this, _extractFields)[_extractFields](type.def.asComposite.fields);
        } else if (type.def.isVariant) {
          typeDef = (0,classPrivateFieldLooseBase/* default */.Z)(this, _extractVariant)[_extractVariant](type.def.asVariant, id);
        } else if (type.def.isArray) {
          typeDef = (0,classPrivateFieldLooseBase/* default */.Z)(this, _extractArray)[_extractArray](type.def.asArray);
        } else if (type.def.isSequence) {
          typeDef = (0,classPrivateFieldLooseBase/* default */.Z)(this, _extractSequence)[_extractSequence](type.def.asSequence, id);
        } else if (type.def.isTuple) {
          typeDef = (0,classPrivateFieldLooseBase/* default */.Z)(this, _extractTuple)[_extractTuple](type.def.asTuple);
        } else {
          throw new Error(`Invalid ink! type at index ${id.toString()}`);
        }

        const displayName = (_path$pop = path.pop()) === null || _path$pop === void 0 ? void 0 : _path$pop.toString();
        return (0,encodeTypes/* withTypeString */.He)(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, displayName ? {
          displayName
        } : {}), path.length > 1 ? {
          namespace: path.map(segment => segment.toString()).join('::')
        } : {}), type.params.length > 0 ? {
          sub: type.params.map(type => this.getMetaTypeDef({
            type
          }))
        } : {}), typeDef));
      }
    });
    Object.defineProperty(this, _extractArray, {
      writable: true,
      value: ({
        len: length,
        type
      }) => {
        (0,index_js_.assert)(!length || length.toNumber() <= 256, 'MetaRegistry: Only support for [Type; <length>], where length <= 256');
        return {
          info: types/* TypeDefInfo.VecFixed */.u.VecFixed,
          length: length.toNumber(),
          sub: this.getMetaTypeDef({
            type
          })
        };
      }
    });
    Object.defineProperty(this, _extractFields, {
      writable: true,
      value: fields => {
        const [isStruct, isTuple] = fields.reduce(([isAllNamed, isAllUnnamed], {
          name
        }) => [isAllNamed && name.isSome, isAllUnnamed && name.isNone], [true, true]);
        (0,index_js_.assert)(isTuple || isStruct, 'Invalid fields type detected, expected either Tuple or Struct');
        const sub = fields.map(({
          name,
          type
        }) => {
          return _objectSpread(_objectSpread({}, this.getMetaTypeDef({
            type
          })), name.isSome ? {
            name: name.unwrap().toString()
          } : {});
        });
        return isTuple && sub.length === 1 ? sub[0] : {
          // check for tuple first (no fields may be available)
          info: isTuple ? types/* TypeDefInfo.Tuple */.u.Tuple : types/* TypeDefInfo.Struct */.u.Struct,
          sub
        };
      }
    });
    Object.defineProperty(this, _extractPrimitive, {
      writable: true,
      value: type => {
        const typeStr = type.def.asPrimitive.type.toString();
        return {
          info: types/* TypeDefInfo.Plain */.u.Plain,
          type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()
        };
      }
    });
    Object.defineProperty(this, _extractPrimitivePath, {
      writable: true,
      value: type => {
        return {
          info: types/* TypeDefInfo.Plain */.u.Plain,
          type: type.path[type.path.length - 1].toString()
        };
      }
    });
    Object.defineProperty(this, _extractSequence, {
      writable: true,
      value: ({
        type
      }, id) => {
        (0,index_js_.assert)(!!type, () => `ContractRegistry: Invalid sequence type found at id ${id.toString()}`);
        return {
          info: types/* TypeDefInfo.Vec */.u.Vec,
          sub: this.getMetaTypeDef({
            type
          })
        };
      }
    });
    Object.defineProperty(this, _extractTuple, {
      writable: true,
      value: ids => {
        return ids.length === 1 ? this.getMetaTypeDef({
          type: ids[0]
        }) : {
          info: types/* TypeDefInfo.Tuple */.u.Tuple,
          sub: ids.map(type => this.getMetaTypeDef({
            type
          }))
        };
      }
    });
    Object.defineProperty(this, _extractVariant, {
      writable: true,
      value: ({
        variants
      }, id) => {
        const {
          params,
          path
        } = (0,classPrivateFieldLooseBase/* default */.Z)(this, _getMetaType)[_getMetaType](id);

        const specialVariant = path[0].toString();

        if (specialVariant === 'Option') {
          return {
            info: types/* TypeDefInfo.Option */.u.Option,
            sub: this.getMetaTypeDef({
              type: params[0]
            })
          };
        } else if (specialVariant === 'Result') {
          return {
            info: types/* TypeDefInfo.Result */.u.Result,
            sub: params.map((type, index) => _objectSpread({
              name: ['Ok', 'Error'][index]
            }, this.getMetaTypeDef({
              type
            })))
          };
        }

        return {
          info: types/* TypeDefInfo.Enum */.u.Enum,
          sub: (0,classPrivateFieldLooseBase/* default */.Z)(this, _extractVariantSub)[_extractVariantSub](variants)
        };
      }
    });
    Object.defineProperty(this, _extractVariantSub, {
      writable: true,
      value: variants => {
        const isAllUnitVariants = variants.every(({
          fields
        }) => fields.length === 0);

        if (isAllUnitVariants) {
          return variants.map(({
            discriminant,
            name
          }) => _objectSpread(_objectSpread({}, discriminant.isSome ? {
            ext: {
              discriminant: discriminant.unwrap().toNumber()
            }
          } : {}), {}, {
            info: types/* TypeDefInfo.Plain */.u.Plain,
            name: name.toString(),
            type: 'Null'
          }));
        }

        return variants.map(({
          fields,
          name
        }) => (0,encodeTypes/* withTypeString */.He)(_objectSpread(_objectSpread({}, (0,classPrivateFieldLooseBase/* default */.Z)(this, _extractFields)[_extractFields](fields)), {}, {
          name: name.toString()
        })));
      }
    });
    this.typeOffset = metadataVersion.split('.')[0] === '0' ? 1 : 0;

    if (chainProperties) {
      this.setChainProperties(chainProperties);
    }
  }

  setMetaTypes(metaTypes) {
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _siTypes)[_siTypes] = metaTypes;
  }

  getMetaTypeDef(typeSpec) {
    const offset = getRegistryOffset(typeSpec.type, this.typeOffset);
    let typeDef = this.metaTypeDefs[offset];

    if (!typeDef) {
      typeDef = (0,classPrivateFieldLooseBase/* default */.Z)(this, _extract)[_extract]((0,classPrivateFieldLooseBase/* default */.Z)(this, _getMetaType)[_getMetaType](typeSpec.type), typeSpec.type);
      this.metaTypeDefs[offset] = typeDef;
    }

    if (typeSpec.displayName && typeSpec.displayName.length) {
      const displayName = typeSpec.displayName[typeSpec.displayName.length - 1].toString();

      if (!typeDef.type.startsWith(displayName)) {
        typeDef = _objectSpread(_objectSpread({}, typeDef), {}, {
          displayName,
          type: PRIMITIVE_ALWAYS.includes(displayName) ? displayName : typeDef.type
        });
      }
    } // Here we protect against the following cases
    //   - No displayName present, these are generally known primitives
    //   - displayName === type, these generate circular references
    //   - displayName Option & type Option<...something...>


    if (typeDef.displayName && !this.hasType(typeDef.displayName) && !(typeDef.type === typeDef.displayName || typeDef.type.startsWith(`${typeDef.displayName}<`))) {
      this.register({
        [typeDef.displayName]: typeDef.type
      });
    }

    return typeDef;
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/Abi.js




function Abi_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function Abi_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Abi_ownKeys(Object(source), true).forEach(function (key) { (0,defineProperty/* default */.Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Abi_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0


const l = (0,index_js_.logger)('Abi');

function findMessage(list, messageOrId) {
  const message = (0,index_js_.isNumber)(messageOrId) ? list[messageOrId] : (0,index_js_.isString)(messageOrId) ? list.find(({
    identifier
  }) => [identifier, (0,index_js_.stringCamelCase)(identifier)].includes(messageOrId.toString())) : messageOrId;
  return (0,index_js_.assertReturn)(message, `Attempted to call an invalid contract interface, ${(0,index_js_.stringify)(messageOrId)}`);
}

var _events = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("events");

var _createArgs = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("createArgs");

var _createEvent = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("createEvent");

var _createMessage = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("createMessage");

var _decodeArgs = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("decodeArgs");

var _decodeMessage = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("decodeMessage");

var _encodeArgs = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("encodeArgs");

class Abi {
  constructor(abiJson, chainProperties) {
    Object.defineProperty(this, _events, {
      writable: true,
      value: void 0
    });
    this.constructors = void 0;
    this.json = void 0;
    this.messages = void 0;
    this.project = void 0;
    this.registry = void 0;
    Object.defineProperty(this, _createArgs, {
      writable: true,
      value: (args, spec) => {
        return args.map((arg, index) => {
          try {
            (0,index_js_.assert)((0,index_js_.isObject)(arg.type), 'Invalid type definition found');
            return {
              name: (0,index_js_.stringCamelCase)(arg.name),
              type: this.registry.getMetaTypeDef(arg.type)
            };
          } catch (error) {
            l.error(`Error expanding argument ${index} in ${(0,index_js_.stringify)(spec)}`);
            throw error;
          }
        });
      }
    });
    Object.defineProperty(this, _createEvent, {
      writable: true,
      value: (spec, index) => {
        const args = (0,classPrivateFieldLooseBase/* default */.Z)(this, _createArgs)[_createArgs](spec.args, spec);

        const event = {
          args,
          docs: spec.docs.map(doc => doc.toString()),
          fromU8a: data => ({
            args: (0,classPrivateFieldLooseBase/* default */.Z)(this, _decodeArgs)[_decodeArgs](args, data),
            event
          }),
          identifier: spec.name.toString(),
          index
        };
        return event;
      }
    });
    Object.defineProperty(this, _createMessage, {
      writable: true,
      value: (spec, index, add = {}) => {
        const args = (0,classPrivateFieldLooseBase/* default */.Z)(this, _createArgs)[_createArgs](spec.args, spec);

        const identifier = spec.name.toString();

        const message = Abi_objectSpread(Abi_objectSpread({}, add), {}, {
          args,
          docs: spec.docs.map(doc => doc.toString()),
          fromU8a: data => ({
            args: (0,classPrivateFieldLooseBase/* default */.Z)(this, _decodeArgs)[_decodeArgs](args, data),
            message
          }),
          identifier,
          index,
          method: (0,index_js_.stringCamelCase)(identifier),
          selector: spec.selector,
          toU8a: params => (0,classPrivateFieldLooseBase/* default */.Z)(this, _encodeArgs)[_encodeArgs](spec, args, params)
        });

        return message;
      }
    });
    Object.defineProperty(this, _decodeArgs, {
      writable: true,
      value: (args, data) => {
        // for decoding we expect the input to be just the arg data, no selectors
        // no length added (this allows use with events as well)
        let offset = 0;
        return args.map(({
          type
        }) => {
          const value = this.registry.createType(type.type, data.subarray(offset));
          offset += value.encodedLength;
          return value;
        });
      }
    });
    Object.defineProperty(this, _decodeMessage, {
      writable: true,
      value: (type, list, data) => {
        const [, trimmed] = (0,index_js_.compactStripLength)(data);
        const selector = trimmed.subarray(0, 4);
        const message = list.find(m => m.selector.eq(selector));
        (0,index_js_.assert)(message, `Unable to find ${type} with selector ${(0,index_js_.u8aToHex)(selector)}`);
        return message.fromU8a(trimmed.subarray(4));
      }
    });
    Object.defineProperty(this, _encodeArgs, {
      writable: true,
      value: ({
        name,
        selector
      }, args, data) => {
        (0,index_js_.assert)(data.length === args.length, () => `Expected ${args.length} arguments to contract message '${name.toString()}', found ${data.length}`);
        return (0,index_js_.compactAddLength)((0,index_js_.u8aConcat)(this.registry.createType('ContractSelector', selector).toU8a(), ...args.map(({
          type
        }, index) => this.registry.createType(type.type, data[index]).toU8a())));
      }
    });
    const json = (0,index_js_.isString)(abiJson) ? JSON.parse(abiJson) : abiJson;
    (0,index_js_.assert)((0,index_js_.isObject)(json) && !Array.isArray(json) && json.metadataVersion && (0,index_js_.isObject)(json.spec) && !Array.isArray(json.spec) && Array.isArray(json.spec.constructors) && Array.isArray(json.spec.messages), 'Invalid JSON ABI structure supplied, expected a recent metadata version');
    this.json = json;
    this.registry = new MetaRegistry(json.metadataVersion, chainProperties);
    this.project = this.registry.createType('ContractProject', json);
    this.registry.setMetaTypes(this.project.types);
    this.project.types.forEach((_, index) => this.registry.getMetaTypeDef({
      type: this.registry.createType('SiLookupTypeId', index + this.registry.typeOffset)
    }));
    this.constructors = this.project.spec.constructors.map((spec, index) => (0,classPrivateFieldLooseBase/* default */.Z)(this, _createMessage)[_createMessage](spec, index, {
      isConstructor: true
    }));
    (0,classPrivateFieldLooseBase/* default */.Z)(this, _events)[_events] = this.project.spec.events.map((spec, index) => (0,classPrivateFieldLooseBase/* default */.Z)(this, _createEvent)[_createEvent](spec, index));
    this.messages = this.project.spec.messages.map((spec, index) => {
      const typeSpec = spec.returnType.unwrapOr(null);
      return (0,classPrivateFieldLooseBase/* default */.Z)(this, _createMessage)[_createMessage](spec, index, {
        isMutating: spec.mutates.isTrue,
        isPayable: spec.payable.isTrue,
        returnType: typeSpec ? this.registry.getMetaTypeDef(typeSpec) : null
      });
    });
  }
  /**
   * Warning: Unstable API, bound to change
   */


  decodeEvent(data) {
    const index = data[0];

    const event = (0,classPrivateFieldLooseBase/* default */.Z)(this, _events)[_events][index];

    (0,index_js_.assert)(event, () => `Unable to find event with index ${index}`);
    return event.fromU8a(data.subarray(1));
  }
  /**
   * Warning: Unstable API, bound to change
   */


  decodeConstructor(data) {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _decodeMessage)[_decodeMessage]('message', this.constructors, data);
  }
  /**
   * Warning: Unstable API, bound to change
   */


  decodeMessage(data) {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _decodeMessage)[_decodeMessage]('message', this.messages, data);
  }

  findConstructor(constructorOrId) {
    return findMessage(this.constructors, constructorOrId);
  }

  findMessage(messageOrId) {
    return findMessage(this.messages, messageOrId);
  }

}
// EXTERNAL MODULE: ../../node_modules/@polkadot/api/promise/index.js + 1 modules
var promise = __webpack_require__(7253);
// EXTERNAL MODULE: consume shared module (default) @polkadot/api@^4.13.1 (strict) (fallback: ../../node_modules/@polkadot/api/index.js)
var api_index_js_ = __webpack_require__(40586);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/util.js
// Copyright 2017-2021 @polkadot/rpc-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0

function applyOnEvent(result, types, fn) {
  if (result.isInBlock || result.isFinalized) {
    const records = result.filterRecords('contracts', types);

    if (records.length) {
      return fn(records);
    }
  }

  return undefined;
}
function util_isOptions(options) {
  return !((0,index_js_.isBn)(options) || (0,index_js_.isBigInt)(options) || (0,index_js_.isNumber)(options) || (0,index_js_.isString)(options));
}
function util_extractOptions(value, params) {
  const gasLimit = params.shift();
  return [{
    gasLimit,
    value
  }, params];
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/base/Base.js
// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0


class Base {
  constructor(api, abi, decorateMethod) {
    var _api$rx$tx$contracts;

    this.abi = void 0;
    this.api = void 0;
    this.registry = void 0;
    this._decorateMethod = void 0;
    this.abi = abi instanceof Abi ? abi : new Abi(abi, api.registry.getChainProperties());
    this.api = api;
    this.registry = this.abi.registry;
    this._decorateMethod = decorateMethod;
    (0,index_js_.assert)((0,index_js_.isFunction)((_api$rx$tx$contracts = api.rx.tx.contracts) === null || _api$rx$tx$contracts === void 0 ? void 0 : _api$rx$tx$contracts.instantiateWithCode), 'You need to connect to a node with a V3 contracts module. Your node does not expose api.tx.contracts.instantiateWithCode on this instance');
  }

}
// EXTERNAL MODULE: ../../node_modules/bn.js/lib/bn.js
var bn = __webpack_require__(62197);
// EXTERNAL MODULE: consume shared module (default) @polkadot/types@^4.13.1 (strict) (fallback: ../../node_modules/@polkadot/types/index.js)
var types_index_js_ = __webpack_require__(71196);
// EXTERNAL MODULE: ../../node_modules/@polkadot/x-rxjs/cjs/operators.js
var operators = __webpack_require__(3191);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/base/Contract.js


// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0






 // As per Rust, 5 * GAS_PER_SEC

const MAX_CALL_GAS = new bn(5000000000000).isub(index_js_.BN_ONE);
const ERROR_NO_CALL = 'Your node does not expose the contracts.call RPC. This is most probably due to a runtime configuration.';
const Contract_l = (0,index_js_.logger)('Contract');

function createQuery(fn) {
  return (origin, options, ...params) => util_isOptions(options) ? fn(origin, options, params) : fn(origin, ...util_extractOptions(options, params));
}

function createTx(fn) {
  return (options, ...params) => util_isOptions(options) ? fn(options, params) : fn(...util_extractOptions(options, params));
}

class ContractSubmittableResult extends api_index_js_.SubmittableResult {
  constructor(result, contractEvents) {
    super(result);
    this.contractEvents = void 0;
    this.contractEvents = contractEvents;
  }

}

var _query = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("query");

var _tx = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("tx");

var _getGas = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("getGas");

var _exec = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("exec");

var _read = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("read");

class Contract_Contract extends Base {
  /**
   * @description The on-chain address for this contract
   */
  constructor(api, abi, address, decorateMethod) {
    super(api, abi, decorateMethod);
    this.address = void 0;
    Object.defineProperty(this, _query, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _tx, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _getGas, {
      writable: true,
      value: (_gasLimit, isCall = false) => {
        const gasLimit = (0,index_js_.bnToBn)(_gasLimit);
        return gasLimit.lte(index_js_.BN_ZERO) ? isCall ? MAX_CALL_GAS : (this.api.consts.system.blockWeights ? this.api.consts.system.blockWeights.maxBlock : this.api.consts.system.maximumBlockWeight).muln(64).div(index_js_.BN_HUNDRED) : gasLimit;
      }
    });
    Object.defineProperty(this, _exec, {
      writable: true,
      value: (messageOrId, {
        gasLimit = index_js_.BN_ZERO,
        value = index_js_.BN_ZERO
      }, params) => {
        return this.api.tx.contracts.call(this.address, value, (0,classPrivateFieldLooseBase/* default */.Z)(this, _getGas)[_getGas](gasLimit), this.abi.findMessage(messageOrId).toU8a(params)).withResultTransform(result => // ContractEmitted is the current generation, ContractExecution is the previous generation
        new ContractSubmittableResult(result, applyOnEvent(result, ['ContractEmitted', 'ContractExecution'], records => records.map(({
          event: {
            data: [, data]
          }
        }) => {
          try {
            return this.abi.decodeEvent(data);
          } catch (error) {
            Contract_l.error(`Unable to decode contract event: ${error.message}`);
            return null;
          }
        }).filter(decoded => !!decoded))));
      }
    });
    Object.defineProperty(this, _read, {
      writable: true,
      value: (messageOrId, {
        gasLimit = index_js_.BN_ZERO,
        value = index_js_.BN_ZERO
      }, params) => {
        (0,index_js_.assert)(this.hasRpcContractsCall, ERROR_NO_CALL);
        const message = this.abi.findMessage(messageOrId);
        return {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          send: this._decorateMethod(origin => this.api.rx.rpc.contracts.call({
            dest: this.address,
            gasLimit: (0,classPrivateFieldLooseBase/* default */.Z)(this, _getGas)[_getGas](gasLimit, true),
            inputData: message.toU8a(params),
            origin,
            value
          }).pipe((0,operators/* map */.UI)(({
            debugMessage,
            gasConsumed,
            result
          }) => ({
            debugMessage,
            gasConsumed,
            output: result.isOk && message.returnType ? (0,types_index_js_.createTypeUnsafe)(this.registry, message.returnType.type, [result.asOk.data.toU8a(true)], {
              isPedantic: true
            }) : null,
            result
          }))))
        };
      }
    });
    this.address = this.registry.createType('AccountId', address);
    this.abi.messages.forEach(m => {
      if ((0,index_js_.isUndefined)((0,classPrivateFieldLooseBase/* default */.Z)(this, _tx)[_tx][m.method])) {
        (0,classPrivateFieldLooseBase/* default */.Z)(this, _tx)[_tx][m.method] = createTx((o, p) => (0,classPrivateFieldLooseBase/* default */.Z)(this, _exec)[_exec](m, o, p));
      }

      if ((0,index_js_.isUndefined)((0,classPrivateFieldLooseBase/* default */.Z)(this, _query)[_query][m.method])) {
        (0,classPrivateFieldLooseBase/* default */.Z)(this, _query)[_query][m.method] = createQuery((f, o, p) => (0,classPrivateFieldLooseBase/* default */.Z)(this, _read)[_read](m, o, p).send(f));
      }
    });
  }

  get hasRpcContractsCall() {
    var _this$api$rx$rpc$cont;

    return (0,index_js_.isFunction)((_this$api$rx$rpc$cont = this.api.rx.rpc.contracts) === null || _this$api$rx$rpc$cont === void 0 ? void 0 : _this$api$rx$rpc$cont.call);
  }

  get query() {
    (0,index_js_.assert)(this.hasRpcContractsCall, ERROR_NO_CALL);
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _query)[_query];
  }

  get tx() {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, _tx)[_tx];
  }

}
// EXTERNAL MODULE: consume shared module (default) @polkadot/util-crypto@^6.7.1 (strict) (fallback: ../../node_modules/@polkadot/util-crypto/index.js)
var util_crypto_index_js_ = __webpack_require__(21050);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/base/util.js
// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0




const EMPTY_SALT = new Uint8Array();
function createBluePrintTx(fn) {
  return (options, ...params) => util_isOptions(options) ? fn(options, params) : fn(...util_extractOptions(options, params));
}
function createBluePrintWithId(fn) {
  return (constructorOrId, options, ...params) => isOptions(options) ? fn(constructorOrId, options, params) : fn(constructorOrId, ...extractOptions(options, params));
}
function encodeSalt(salt = (0,util_crypto_index_js_.randomAsU8a)()) {
  return salt instanceof types_index_js_.Bytes ? salt : salt && salt.length ? (0,index_js_.compactAddLength)((0,index_js_.u8aToU8a)(salt)) : EMPTY_SALT;
}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/base/Blueprint.js


// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0






class BlueprintSubmittableResult extends api_index_js_.SubmittableResult {
  constructor(result, contract) {
    super(result);
    this.contract = void 0;
    this.contract = contract;
  }

}

var Blueprint_tx = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("tx");

var _deploy = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("deploy");

class Blueprint_Blueprint extends Base {
  /**
   * @description The on-chain code hash for this blueprint
   */
  constructor(api, abi, codeHash, decorateMethod) {
    super(api, abi, decorateMethod);
    this.codeHash = void 0;
    Object.defineProperty(this, Blueprint_tx, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _deploy, {
      writable: true,
      value: (constructorOrId, {
        gasLimit = index_js_.BN_ZERO,
        salt,
        value = index_js_.BN_ZERO
      }, params) => {
        return this.api.tx.contracts.instantiate(value, gasLimit, this.codeHash, this.abi.findConstructor(constructorOrId).toU8a(params), encodeSalt(salt)).withResultTransform(result => new BlueprintSubmittableResult(result, applyOnEvent(result, ['Instantiated'], ([record]) => new Contract_Contract(this.api, this.abi, record.event.data[1], this._decorateMethod))));
      }
    });
    this.codeHash = this.registry.createType('Hash', codeHash);
    this.abi.constructors.forEach(c => {
      if ((0,index_js_.isUndefined)((0,classPrivateFieldLooseBase/* default */.Z)(this, Blueprint_tx)[Blueprint_tx][c.method])) {
        (0,classPrivateFieldLooseBase/* default */.Z)(this, Blueprint_tx)[Blueprint_tx][c.method] = createBluePrintTx((o, p) => (0,classPrivateFieldLooseBase/* default */.Z)(this, _deploy)[_deploy](c, o, p));
      }
    });
  }

  get tx() {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, Blueprint_tx)[Blueprint_tx];
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/promise/Blueprint.js
// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0


class Blueprint extends Blueprint_Blueprint {
  constructor(api, abi, codeHash) {
    super(api, abi, codeHash, promise/* decorateMethod */.g);
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/base/Code.js


// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0







class CodeSubmittableResult extends api_index_js_.SubmittableResult {
  constructor(result, blueprint, contract) {
    super(result);
    this.blueprint = void 0;
    this.contract = void 0;
    this.blueprint = blueprint;
    this.contract = contract;
  }

}

var Code_tx = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("tx");

var _instantiate = /*#__PURE__*/(0,classPrivateFieldLooseKey/* default */.Z)("instantiate");

class Code_Code extends Base {
  constructor(api, abi, wasm, decorateMethod) {
    super(api, abi, decorateMethod);
    this.code = void 0;
    Object.defineProperty(this, Code_tx, {
      writable: true,
      value: {}
    });
    Object.defineProperty(this, _instantiate, {
      writable: true,
      value: (constructorOrId, {
        gasLimit = index_js_.BN_ZERO,
        salt,
        value = index_js_.BN_ZERO
      }, params) => {
        return this.api.tx.contracts.instantiateWithCode(value, gasLimit, (0,index_js_.compactAddLength)(this.code), this.abi.findConstructor(constructorOrId).toU8a(params), encodeSalt(salt)).withResultTransform(result => new CodeSubmittableResult(result, ...(applyOnEvent(result, ['CodeStored', 'Instantiated'], records => records.reduce(([blueprint, contract], {
          event
        }) => this.api.events.contracts.Instantiated.is(event) ? [blueprint, new Contract_Contract(this.api, this.abi, event.data[1], this._decorateMethod)] : this.api.events.contracts.CodeStored.is(event) ? [new Blueprint_Blueprint(this.api, this.abi, event.data[0], this._decorateMethod), contract] : [blueprint, contract], [])) || [])));
      }
    });
    this.code = (0,index_js_.isWasm)(this.abi.project.source.wasm) ? this.abi.project.source.wasm : (0,index_js_.u8aToU8a)(wasm);
    (0,index_js_.assert)((0,index_js_.isWasm)(this.code), 'No WASM code provided');
    this.abi.constructors.forEach(c => {
      if ((0,index_js_.isUndefined)((0,classPrivateFieldLooseBase/* default */.Z)(this, Code_tx)[Code_tx][c.method])) {
        (0,classPrivateFieldLooseBase/* default */.Z)(this, Code_tx)[Code_tx][c.method] = createBluePrintTx((o, p) => (0,classPrivateFieldLooseBase/* default */.Z)(this, _instantiate)[_instantiate](c, o, p));
      }
    });
  }

  get tx() {
    return (0,classPrivateFieldLooseBase/* default */.Z)(this, Code_tx)[Code_tx];
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/promise/Code.js
// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0


class Code extends Code_Code {
  constructor(api, abi, wasm) {
    super(api, abi, wasm, promise/* decorateMethod */.g);
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/promise/Contract.js
// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0


class Contract extends Contract_Contract {
  constructor(api, abi, address) {
    super(api, abi, address, promise/* decorateMethod */.g);
  }

}
// EXTERNAL MODULE: ../../node_modules/@polkadot/api/rx/index.js
var rx = __webpack_require__(11945);
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/rx/Blueprint.js
// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0


class rx_Blueprint_Blueprint extends Blueprint_Blueprint {
  constructor(api, abi, codeHash) {
    super(api, abi, codeHash, rx/* decorateMethod */.G);
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/rx/Code.js
// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0


class rx_Code_Code extends Code_Code {
  constructor(api, abi, wasm) {
    super(api, abi, wasm, rx/* decorateMethod */.G);
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/rx/Contract.js
// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0


class rx_Contract_Contract extends Contract_Contract {
  constructor(api, abi, address) {
    super(api, abi, address, rx/* decorateMethod */.G);
  }

}
;// CONCATENATED MODULE: ../../node_modules/@polkadot/api-contract/index.js
// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0






/***/ }),

/***/ 11945:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "G": () => (/* binding */ decorateMethod),
/* harmony export */   "P": () => (/* binding */ ApiRx)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51119);
/* harmony import */ var _babel_runtime_helpers_esm_classPrivateFieldLooseBase__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89539);
/* harmony import */ var _babel_runtime_helpers_esm_classPrivateFieldLooseKey__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38879);
/* harmony import */ var _polkadot_x_rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(365);
/* harmony import */ var _base_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87982);




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Copyright 2017-2021 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0


function decorateMethod(method) {
  return method;
}
/**
 * # @polkadot/api/rx
 *
 *  ## Overview
 *
 * @name ApiRx
 *
 * @description
 * ApiRx is a powerful RxJS Observable wrapper around the RPC and interfaces on the Polkadot network. As a full Observable API, all interface calls return RxJS Observables, including the static `.create(...)`. In the same fashion and subscription-based methods return long-running Observables that update with the latest values.
 *
 * The API is well suited to real-time applications where the latest state is needed, unlocking the subscription-based features of Polkadot (and Substrate) clients. Some familiarity with RxJS is a requirement to use the API, however just understanding `.subscribe` and `.pipe` on Observables will unlock full-scale use thereof.
 *
 * @see [[ApiPromise]]
 *
 * ## Usage
 *
 * Making rpc calls -
 * <BR>
 *
 * ```javascript
 * import ApiRx from '@polkadot/api/rx';
 *
 * // initialize via Promise & static create
 * const api = await ApiRx.create().toPromise();
 *
 * // make a call to retrieve the current network head
 * api.rpc.chain.subscribeNewHeads().subscribe((header) => {
 *   console.log(`Chain is at #${header.number}`);
 * });
 * ```
 * <BR>
 *
 * Subscribing to chain state -
 * <BR>
 *
 * ```javascript
 * import { combineLatest } from '@polkadot/x-rxjs';
 * import { pairwise, switchMap } from '@polkadot/x-rxjs/operators';
 * import { ApiRx, WsProvider } from '@polkadot/api';
 *
 *
 * // initialize a provider with a specific endpoint
 * const provider = new WsProvider('wss://example.com:9944')
 *
 * // initialize via isReady & new with specific provider
 * new ApiRx({ provider })
 *   .isReady
 *   .pipe(
 *     switchMap((api) =>
 *       combineLatest([
 *         api.query.timestamp.blockPeriod(),
 *         api.query.timestamp.now().pipe(pairwise())
 *       ])
 *     )
 *   )
 *   .subscribe(([blockPeriod, timestamp]) => {
 *      const elapsed = timestamp[1].toNumber() - timestamp[0].toNumber();
 *      console.log(`timestamp ${timestamp[1]} \nelapsed ${elapsed} \n(${blockPeriod}s target)`);
 *   });
 * ```
 * <BR>
 *
 * Submitting a transaction -
 * <BR>
 *
 * ```javascript
 * import { first, switchMap } from '@polkadot/x-rxjs/operators';
 * import ApiRx from '@polkadot/api/rx';
 *
 * // import the test keyring (already has dev keys for Alice, Bob, Charlie, Eve & Ferdie)
 * import testingPairs from '@polkadot/keyring/testingPairs';
 * const keyring = testingPairs();
 *
 * // get api via Promise
 * const api = await ApiRx.create().toPromise();
 *
 * // retrieve nonce for the account
 * api.query.system
 *   .account(keyring.alice.address)
 *   .pipe(
 *      first(),
 *      // pipe nonce into transfer
 *      switchMap(([nonce]) =>
 *        api.tx.balances
 *          // create transfer
 *          .transfer(keyring.bob.address, 12345)
 *          // sign the transaction
 *          .sign(keyring.alice, { nonce })
 *          // send the transaction
 *          .send()
 *      )
 *   )
 *   // subscribe to overall result
 *   .subscribe(({ status }) => {
 *     if (status.isInBlock) {
 *       console.log('Completed at block hash', status.asFinalized.toHex());
 *     }
 *   });
 * ```
 */

var _isReadyRx = /*#__PURE__*/(0,_babel_runtime_helpers_esm_classPrivateFieldLooseKey__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z)("isReadyRx");

class ApiRx extends _base_index_js__WEBPACK_IMPORTED_MODULE_3__/* .ApiBase */ .q {
  /**
   * @description Creates an ApiRx instance using the supplied provider. Returns an Observable containing the actual Api instance.
   * @param options options that is passed to the class constructor. Can be either [[ApiOptions]] or [[WsProvider]]
   * @example
   * <BR>
   *
   * ```javascript
   * import { switchMap } from '@polkadot/x-rxjs/operators';
   * import Api from '@polkadot/api/rx';
   *
   * Api.create()
   *   .pipe(
   *     switchMap((api) =>
   *       api.rpc.chain.subscribeNewHeads()
   *   ))
   *   .subscribe((header) => {
   *     console.log(`new block #${header.number.toNumber()}`);
   *   });
   * ```
   */
  static create(options) {
    return new ApiRx(options).isReady;
  }
  /**
   * @description Create an instance of the ApiRx class
   * @param options Options to create an instance. Can be either [[ApiOptions]] or [[WsProvider]]
   * @example
   * <BR>
   *
   * ```javascript
   * import { switchMap } from '@polkadot/x-rxjs/operators';
   * import Api from '@polkadot/api/rx';
   *
   * new Api().isReady
   *   .pipe(
   *     switchMap((api) =>
   *       api.rpc.chain.subscribeNewHeads()
   *   ))
   *   .subscribe((header) => {
   *     console.log(`new block #${header.number.toNumber()}`);
   *   });
   * ```
   */


  constructor(options) {
    super(options, 'rxjs', decorateMethod);
    Object.defineProperty(this, _isReadyRx, {
      writable: true,
      value: void 0
    });
    (0,_babel_runtime_helpers_esm_classPrivateFieldLooseBase__WEBPACK_IMPORTED_MODULE_4__/* .default */ .Z)(this, _isReadyRx)[_isReadyRx] = (0,_polkadot_x_rxjs__WEBPACK_IMPORTED_MODULE_1__.from)( // You can create an observable from an event, however my mind groks this form better
    new Promise(resolve => {
      super.on('ready', () => resolve(this));
    }));
  }
  /**
   * @description Observable that returns the first time we are connected and loaded
   */


  get isReady() {
    return (0,_babel_runtime_helpers_esm_classPrivateFieldLooseBase__WEBPACK_IMPORTED_MODULE_4__/* .default */ .Z)(this, _isReadyRx)[_isReadyRx];
  }
  /**
   * @description Returns a clone of this ApiRx instance (new underlying provider connection)
   */


  clone() {
    return new ApiRx(_objectSpread(_objectSpread({}, this._options), {}, {
      source: this
    }));
  }

}

/***/ })

}]);